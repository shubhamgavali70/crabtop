use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

use std::env;

#[derive(Serialize)]
struct GeminiRequest {
    contents: Vec<Content>,
}

#[derive(Serialize)]
struct Content {
    parts: Vec<Part>,
}

#[derive(Serialize)]
struct Part {
    text: String,
}

#[derive(Deserialize)]
struct GeminiResponse {
    candidates: Vec<Candidate>,
}

#[derive(Deserialize)]
struct Candidate {
    content: ResponseContent,
}

#[derive(Deserialize)]
struct ResponseContent {
    parts: Vec<ResponsePart>,
}

#[derive(Deserialize)]
struct ResponsePart {
    text: String,
}

pub fn analyze_system_data(
    system_info: &str,
    process_info: &str,
    port: u16,
    process_name: &str,
) -> Result<String> {
    let api_key = env::var("GEMINI_API_KEY")
        .context("GEMINI_API_KEY environment variable not set. Get your API key from https://aistudio.google.com/app/apikey")?;

    let prompt = format!(
        r#"You are an expert system administrator analyzing system and process metrics. 
        
**Context:**
- Monitoring process '{process_name}' on port {port}

**System Metrics:**
{system_info}

**Process Details:**
{process_info}

**Your Task:**
Analyze this data and provide a concise, visually appealing terminal output that includes:

1. ðŸŽ¯ **System Health Overview** - Brief assessment of overall system state
2. ðŸ“Š **Process Analysis** - Key insights about the monitored process
3. ðŸ’¡ **Observations** - Notable patterns or potential concerns
4. âœ¨ **Recommendations** - Any actionable suggestions (if applicable)

**Format Guidelines:**
- Use emojis for visual appeal
- Keep it concise (max 10-12 lines)
- Use bullet points for clarity
- Highlight critical metrics
- Make it easy to scan at a glance

Present your analysis in a clean, terminal-friendly format."#
    );

    let request_body = GeminiRequest {
        contents: vec![Content {
            parts: vec![Part { text: prompt }],
        }],
    };

    let url = format!(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key={}",
        api_key
    );

    let client = reqwest::blocking::Client::new();
    let response = client
        .post(&url)
        .header("Content-Type", "application/json")
        .json(&request_body)
        .send()
        .context("Failed to send request to Gemini API")?;

    if !response.status().is_success() {
        let status = response.status();
        let error_text = response.text().unwrap_or_else(|_| "Unknown error".to_string());
        anyhow::bail!("Gemini API request failed with status {}: {}", status, error_text);
    }

    let gemini_response: GeminiResponse = response
        .json()
        .context("Failed to parse Gemini API response")?;

    let analysis = gemini_response
        .candidates
        .first()
        .and_then(|c| c.content.parts.first())
        .map(|p| p.text.clone())
        .context("No response generated by Gemini")?;

    Ok(analysis)
}
